计算法一般按如下步骤进行：

 CRC-16校验码计算方法常有 ：

1，查表法

     查表法是将移位异或的计算结果做成了一个表，就是将0~256放入一个长度为16位的寄存器中的低八位，高八位填充0，然后将该寄存器与多项式0XA001按照上述3、4步骤，直到八位全部移出，最后寄存器中的值就是表格中的数据，高八位、低八位分别单独一个表。

 参考：http://blog.csdn.net/zgrjkflmkyc/article/details/41073435

特点：速度快，语句少，但表格占用一定的程序空间。
2，计算法

 计算法一般按如下步骤进行：
（1），先定义一个16位的CRC寄存器，预置初值为十六进制0xffff（即全为1）；

（2）、把第一个8位二进制数据（既通讯信息帧的第一个字节）与16位的CRC寄存器的低
       8位相异或，把结果放于CRC寄存器，高八位数据不变；
（3）、把CRC寄存器的内容右移一位（朝低位）用0填补最高位，并检查右移后的移出位；
（4）、如果移出位为0：重复第3步（再次右移一位）；如果移出位为1，CRC寄存器与多

    项式A001（1010 0000 0000 0001）进行异或；
（5）、重复步骤3和4，直到右移8次，这样整个8位数据全部进行了处理；
（6）、重复步骤2到步骤5，进行通讯信息帧下一个字节的处理；
（7）、将该通讯信息帧所有字节按上述步骤计算完成后，得到的16位CRC寄存器的高、低
       字节进行交换；
（8）、最后得到的CRC寄存器内容即为：CRC码。

 

 以上计算步骤中的多项式A001是8005按位颠倒后的结果。

unsigned int YCProtocol:: CRC16_21(CString value)
{
	unsigned int crc = 0xFFFF;
	unsigned int tmp = 0;
	int len = value.GetLength() / 2;
	for (int pos = 0; pos < len; pos++)
	{
		tmp =_tcstoul( value.Mid(pos*2,2),0,16);
		crc ^= tmp;          // XOR byte into least sig. byte of crc
		for (int i = 8; i != 0; i--) {    // Loop over each bit
			if ((crc & 0x0001) != 0) {      // If the LSB is set
				crc >>= 1;                    // Shift right and XOR 0xA001
				crc ^= 0xA001;
			}
			else                            // Else LSB is not set
				crc >>= 1;                    // Just shift right
		}
	}
	// Note, this number has low and high bytes swapped, so use it accordingly (or swap bytes)

	tmp = (crc >> 8) + ((crc % 0x100)<<8);//swapped 
	return tmp;
}


模2运算是一种二进制算法，CRC校验技术中的核心部分，因此，我们在分析CRC算法之前，必须掌握模2运算的规则。与四则运算相同，模2运算也包括模2加、模2减、模2乘、模2除四种二进制运算。而且，模2运算也使用与四则运算相同的运算符，即“＋”表示模2加，“－”表示模2减，“×”或“·”表示模2乘，“÷”或“/”表示模2除。与四则运算不同的是模2运算不考虑进位和借位，即模2加法是不带进位的二进制加法运算，模2减法是不带借位的二进制减法运算。这样，两个二进制位相运算时，这两个位的值就能确定运算结果，不受前一次运算的影响，也不对下一次造成影响。

①模2加法运算定义为：
0＋0＝0        0＋1＝1        1＋0＝1        1＋1＝0
例如0101＋0011＝0110，列竖式计算：
   0 1 0 1
＋0 0 1 1
──────
   0 1 1 0

②模2减法运算定义为：
0－0＝0        0－1＝1        1－0＝1        1－1＝0
例如0110－0011＝0101，列竖式计算：
   0 1 1 0
－  0 0 1 1
──────
   0 1 0 1

③模2乘法运算定义为：
0×0＝0        0×1＝0        1×0＝0        1×1＝1
多位二进制模2乘法类似于普通意义上的多位二进制乘法，不同之处在于后者累加中间结果（或称部分积）时采用带进位的加法，而模2乘法对中间结果的处理方式采用的是模2加法。例如1011×101＝100111，列竖式计算：
       1 0 1 1
     ×  1 0 1
    ──────
            1 0 1 1
     0 0 0 0
＋1 0 1 1
────────
   1 0 0 1 1 1

④模2除法运算定义为：
0÷1＝0        1÷1＝1

除数首位必为1
被除数首位为1 商为1 与除数做异或
余数除掉首位 若首位为1则商为1 与除数做异或 若首位为0 则商为0 与全0做异或
余数除掉首位 若首位为1则商为1 与除数做异或 若首位为0 则商为0 与全0做异或
余数除掉首位 若首位为1则商为1 与除数做异或 若首位为0 则商为0 与全0做异或
。。。。。。。
余数位数小于除数位数，运算结束。

               1 1 1 0
       ────────────────
1 0 1 1〕1 1 0 0 1 0 0
      － 1 0 1 1
      ──────
           1 1 1 1
        － 1 0 1 1
       ──────
             1 0 0 0
          － 1 0 1 1
         ──────
               0 1 1 0
            － 0 0 0 0
           ──────
                 1 1 0